# ADR-0002: Data contracts, schema versioning, and enforcement at Medallion boundaries

**Status:** Proposed  
**Date:** 2026-01-31  
**Owners:** Data Platform (Project)  
**Decision Drivers:** schema stability, controlled evolution, CI enforceability, auditability, training-serving skew prevention, reproducibility

## Context

ADR-0001 standardizes on **Delta Lake** for Bronze/Silver/Gold to enable ACID semantics, idempotent merges, and reproducible Gold snapshots. That solves transactional correctness, but it does **not** by itself prevent:

- **Silent schema drift** (new/missing columns, type changes) breaking downstream jobs or corrupting feature logic.
- **Uncontrolled evolution** where a “working” pipeline gradually diverges from documented assumptions.
- **Training-serving skew** caused by feature schema changes without explicit versioning.

This project needs **enforceable data contracts** with explicit schema versioning so the Silver boundary is trustworthy and Gold features are stable for model training and API serving.

## Decision

1. **Adopt repo-managed data contracts for every Silver and Gold table** (and capture schema fingerprints for Bronze).
2. **Version schemas explicitly** using `schema_version` and compute a deterministic `schema_hash` for governance and traceability.
3. **Enforce contracts at write time**:
   - Silver writes must validate inputs and outputs against the Silver contract before commit.
   - Gold feature snapshots must validate output schema exactly (no implicit drift).
4. **Treat schema evolution as a controlled change process**:
   - Additive changes are allowed only with a contract update and version bump.
   - Breaking changes require a new contract version and a backfill/migration plan.

## Contract scope by layer

### Bronze (capture, don’t enforce)

- Bronze preserves raw fidelity; schema may vary by source extract.
- Bronze tables **must** store `_schema_hash` (observed schema fingerprint) and ingestion metadata.
- Bronze contracts are optional; the primary goal is **traceability**, not enforcement.

### Silver (enforce “trusted shape”)

- Silver tables **must** have a contract defining the trusted schema and key constraints.
- Contract checks run before committing writes (including `MERGE INTO` operations).

### Gold (enforce “model/serving shape”)

- Gold feature snapshots **must** have a contract with a strict, stable feature schema.
- Output must match contract exactly to prevent training-serving skew.

## Contract format and storage

Contracts live in the repo, keyed by the stable `table_id` convention from ADR-0001:

```

contracts/
silver/<domain>/<table>.yaml
gold/<domain>/<table>.yaml

```

**Minimum required fields per contract**
- `table_id` (e.g., `silver.commerce.orders_clean`)
- `schema_version` (integer)
- `columns`: name, type, nullable
- `primary_keys` (list)
- `partition_cols` (list)
- `constraints` (non-null, uniqueness expectations, allowed enums where applicable)

**Gold contracts additionally include**
- `feature_set` name and intended join key(s) (e.g., `customer_id`)
- `pitrules` notes (e.g., “events <= as_of_ts only”)
- Required snapshot keys: `(customer_id, as_of_date)` (or equivalent)

## Schema hash strategy

We compute a deterministic `schema_hash` (SHA-256) from a canonicalized schema representation:

- For Spark: canonical JSON of `StructType` (ordered fields, normalized type strings, normalized nullability).
- `schema_hash` is persisted as:
  - a table property (preferred) and/or a metadata column on writes (e.g., `_schema_hash`)
  - an entry in a small metadata store for cross-run comparisons (PostgreSQL in this project)

This makes schema changes observable and auditable even when the table format supports evolution.

## Compatibility rules (enforced)

We define compatibility per layer as follows:

### Silver compatibility
Allowed with contract update + `schema_version` bump:
- **Additive columns** (new nullable columns or new columns with defaults applied upstream)

Not allowed without a controlled migration:
- Column type changes (e.g., `int -> string`)
- Column deletions
- Renames (treated as delete + add unless explicitly migrated)
- Primary key changes

### Gold compatibility
Gold feature schemas are treated as **strict**:
- Output schema must match contract exactly for a given `schema_version`.
- Additive features require a new `schema_version` and should produce a new `feature_version` for traceability.

## Enforcement points

### At Silver write (mandatory)

Before committing a Silver table write:
1. Load Silver contract by `table_id`.
2. Validate dataframe schema:
   - required columns present
   - types match
   - nullability consistent (contract is the upper bound)
3. Validate key constraints at minimum:
   - non-null primary keys
   - no duplicate keys in the output batch (or enforce via merge logic + post-check)
4. If validation fails: **fail fast** (do not write/merge).

### At Gold snapshot write (mandatory)

Before committing a Gold snapshot partition:
1. Load Gold contract by `table_id`.
2. Validate output schema exact match (columns/types).
3. Persist `schema_version` and `schema_hash` as metadata for the snapshot build.

## Options considered

### Option A — Repo-managed contracts + schema_version + schema_hash (Chosen)

**Pros**
- Simple, reviewable change control via Git.
- CI-friendly: contracts can be linted and validated before merges.
- Works naturally with Spark + Delta and the project’s governance requirements.

**Cons**
- Requires discipline: contract updates must be part of schema changes.
- Adds lightweight maintenance overhead (expected in production).

### Option B — External Schema Registry (Avro/Protobuf/Confluent-style)

**Pros**
- Strong governance patterns; centralized compatibility checks.

**Cons**
- Extra infrastructure and integration overhead for a lean project.
- Better fit for streaming/event-first architectures than batch lakehouse tables.

### Option C — Rely on Delta schema evolution only (Rejected)

**Pros**
- Minimal upfront work.

**Cons**
- Drift is easy and often silent.
- Does not provide the explicit enforcement needed at Silver/Gold boundaries.
- Increases risk of training-serving skew.

## Consequences

### Positive

- Silver becomes an enforceable “trusted boundary” instead of a convention.
- Schema changes become intentional and reviewable (Git history + version bumps).
- Gold feature schemas remain stable, reducing training-serving skew risk.
- Stronger governance: `schema_version` and `schema_hash` are available for audits and debugging.

### Negative / Risks

- Contract updates add a small amount of process overhead.
- Poor canonicalization can cause unstable hashes if not implemented carefully.
- Overly strict contracts can slow iteration if not scoped thoughtfully (use Bronze for flexibility).

## Implementation notes

### Contract loader + validator

Add a small contracts module:

- `src/common/contracts/`
  - `load_contract(table_id) -> Contract`
  - `schema_hash(struct_type) -> str`
  - `validate_schema(df, contract, strict: bool) -> None`
  - `validate_keys(df, contract) -> None`

### Metadata recording (PostgreSQL)

Track contract and schema events:

- `table_registry(table_id, layer, location, primary_keys, partition_cols, contract_path)`
- `schema_history(table_id, schema_version, schema_hash, changed_at, changed_by, notes)`

### Pipeline integration points

- Silver: validation runs immediately before `MERGE INTO` commit.
- Gold: validation runs immediately before snapshot write.
- MLflow: log `feature_schema_version` and `feature_schema_hash` as run tags for training runs.
- FastAPI: return a `feature_version` derived from:
  - `gold table_id`
  - `as_of_date`
  - `schema_version` (and optionally `schema_hash`)

## Acceptance criteria

This ADR is “done” when:

1. A deliberate schema drift (e.g., type change) in a Silver job causes a **hard failure** before writing.
2. Adding a new nullable column requires a **contract update** and increments `schema_version`.
3. Gold feature snapshot outputs include recorded `schema_version` and `schema_hash`, and training runs log them in MLflow.

## Follow-ups

- ADR-0003: data quality gates (constraints + anomaly checks aligned with Silver enforcement)
- Add a contract CI check: validate contract files, generate expected Spark schemas, and diff vs produced schemas in unit tests
- Add a small “contract bootstrapper” script to generate initial contract YAMLs from Spark schemas for the first pass
